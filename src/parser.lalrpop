// -*- Rust -*-

use std::str::FromStr;
use crate::sxp::ast::{AST, ASTF};
use crate::sxp::string;
use crate::pipeline::source::SourceOffset;

grammar;

Int: i32 = <s:INT> => i32::from_str(s).unwrap();
Float: f32 = <s:FLOAT> => f32::from_str(s).unwrap();
String: String = <s:STRING> => {
  let t = &s[1..s.chars().count()-1];
  string::parse_escapes(t).unwrap()
};
Symbol: String = <s:SYMBOL> => String::from(s);
NodePath: String = <s:PATH> => String::from(&s[1..]);

// TODO I want to be able to recognize symbols like 1b or a.b. I think
// I'll have to write my own custom lexer to do so.
match {
  r"\s*" => {},
  r";[^\n\r]*[\n\r]?" => {}, // Line comments (starting with semicolon)
  r"#\|([^|]|\|[^#])*\|#" => {}, // Block comments (nesting is not currently allowed)
  "#t", "#f",
  r"[+-]?[0-9]+" => INT,
  r"[+-]?[0-9]+((\.[0-9]+)([eE][+-]?[0-9]+)?|(\.[0-9]+)?([eE][+-]?[0-9]+))" => FLOAT,
  r#""([^\\"]|\\[\\"])*""# => STRING,
  r"\$[A-Za-z0-9_~+=\-\\!$%^&*<>/?]+" => PATH,
  "(", ")", ".", "[", "]", "'", "#'", "`", ",", ":", "V{", "{", "}", ",.", "@",
} else {
  r"[A-Za-z_~+=\-\\!%^&*<>/?][A-Za-z0-9_~+=\-\\!$%^&*<>/?]*(\.[A-Za-z0-9_~+=\-\\!$%^&*<>/?]+)*" => SYMBOL,
}

pub AST: AST = {
  <ast: LiteralOrNestedAST> => ast,
  <pos:@L> "'" <body: AST> => AST::dotted_list(vec!(AST::new(ASTF::Symbol(String::from("quote")), SourceOffset(pos)), body), AST::new(ASTF::Nil, SourceOffset(pos))),
  <pos:@L> "#'" <body: AST> => AST::dotted_list(vec!(AST::new(ASTF::Symbol(String::from("function")), SourceOffset(pos)), body), AST::new(ASTF::Nil, SourceOffset(pos))),
  <pos:@L> "`" <body: AST> => AST::dotted_list(vec!(AST::new(ASTF::Symbol(String::from("quasiquote")), SourceOffset(pos)), body), AST::new(ASTF::Nil, SourceOffset(pos))),
  <pos:@L> "," <body: AST> => AST::dotted_list(vec!(AST::new(ASTF::Symbol(String::from("unquote")), SourceOffset(pos)), body), AST::new(ASTF::Nil, SourceOffset(pos))),
  <pos:@L> ",." <body: AST> => AST::dotted_list(vec!(AST::new(ASTF::Symbol(String::from("unquote-spliced")), SourceOffset(pos)), body), AST::new(ASTF::Nil, SourceOffset(pos))),
}

pub SomeAST: AST = {
  <pos:@L> <one: AST> => AST::new(ASTF::cons(one, AST::new(ASTF::Nil, SourceOffset(pos))), SourceOffset(pos)),
  <pos:@L> <first: AST> <rest: SomeAST> => AST::new(ASTF::cons(first, rest), SourceOffset(pos)),
}

// This is here to fix an ambiguity with the grammar. Specifically, I
// want ' a : b to parse as (quote (access-slot a b)), not
// (access-slot (quote a) b). There is never a use case where the
// latter would be helpful, as (quote a) has no GDScript-only slots on
// it. The same applies to function and quasiquote. unquote is a bit
// more nebulous, as there are use cases for either possible parse of
// ,a:b, but I'm treating it the same as the other three for now.
pub LiteralOrNestedAST: AST = {
  <pos:@L> "#t" => AST::new(ASTF::Bool(true), SourceOffset(pos)),
  <pos:@L> "#f" => AST::new(ASTF::Bool(false), SourceOffset(pos)),
  <pos:@L> <i: Int> => AST::new(ASTF::Int(i), SourceOffset(pos)),
  <pos:@L> <f: Float> => AST::new(ASTF::Float(f.into()), SourceOffset(pos)),
  <pos:@L> <s: String> => AST::new(ASTF::String(s), SourceOffset(pos)), // TODO Escaping
  <pos:@L> <s: Symbol> => AST::new(ASTF::Symbol(s), SourceOffset(pos)),
  <pos:@L> "(" ")" => AST::new(ASTF::Nil, SourceOffset(pos)),
  <pos:@L> "(" <car: AST> <cdr: Cdr> ")" => AST::new(ASTF::Cons(Box::new(car), Box::new(cdr)), SourceOffset(pos)),
  <pos:@L> "[" <contents: ArrayContents> "]" => AST::new(ASTF::Array(contents), SourceOffset(pos)),
  <pos:@L> "{" <contents: DictContents> "}" => AST::new(ASTF::Dictionary(contents), SourceOffset(pos)),
  <pos:@L> "V{" <x: AST> <y: AST> "}" => AST::dotted_list(vec!(AST::symbol("vector", SourceOffset(pos)), x, y), AST::nil(SourceOffset(pos))),
  <pos:@L> "V{" <x: AST> <y: AST> <z: AST> "}" => AST::dotted_list(vec!(AST::symbol("vector", SourceOffset(pos)), x, y, z), AST::nil(SourceOffset(pos))),
  <pos:@L> <body: LiteralOrNestedAST> ":" <rpos:@L> <name: Symbol> => AST::dotted_list(vec!(AST::symbol("access-slot", SourceOffset(pos)), body, AST::new(ASTF::Symbol(name), SourceOffset(rpos))), AST::nil(SourceOffset(pos))),
  <pos:@L> <body: LiteralOrNestedAST> ":" <rpos:@L> <path: NodePath> => AST::dotted_list(vec!(AST::dotted_list(vec!(AST::symbol("access-slot", SourceOffset(pos)), body, AST::symbol("get-node", SourceOffset(pos))), AST::nil(SourceOffset(pos))), AST::new(ASTF::String(path), SourceOffset(rpos))), AST::nil(SourceOffset(pos))),
  <pos:@L> <path: NodePath> => AST::dotted_list(vec!(AST::dotted_list(vec!(AST::symbol("access-slot", SourceOffset(pos)), AST::symbol("self", SourceOffset(pos)), AST::symbol("get-node", SourceOffset(pos))), AST::nil(SourceOffset(pos))), AST::new(ASTF::String(path), SourceOffset(pos))), AST::nil(SourceOffset(pos))),
  <pos:@L> "@" <rpos:@L> <name: Symbol> => AST::dotted_list(vec!(AST::symbol("access-slot", SourceOffset(pos)), AST::symbol("self", SourceOffset(pos)), AST::new(ASTF::Symbol(name), SourceOffset(rpos))), AST::nil(SourceOffset(pos))),
}

Cdr: AST = {
  <pos:@L> => AST::nil(SourceOffset(pos)),
  "." <cdr: AST> => cdr,
  <pos:@L> <cadr: AST> <cddr: Cdr> => AST::new(ASTF::Cons(Box::new(cadr), Box::new(cddr)), SourceOffset(pos)),
}

ArrayContents: Vec<AST> = {
  => vec!(),
  <mut init: ArrayContents> <last: AST> => {
    init.push(last);
    init
  }
}

DictContents: Vec<(AST, AST)> = {
  => vec!(),
  <mut init: DictContents> <lastk: AST> <lastv: AST> => {
    init.push((lastk, lastv));
    init
  }
}
