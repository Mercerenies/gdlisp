// Copyright 2023, 2024 Silvio Mayolo
//
// This file is part of GDLisp.
//
// GDLisp is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// GDLisp is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GDLisp. If not, see <https://www.gnu.org/licenses/>.

//! This module provides several helpers for syntactic forms which are
//! specially constructed during parsing.
//!
//! This includes forms such as `(quote x)`, which is generated by the
//! `'x` syntax.

use crate::sexpr::SExpr;
use gdlisp_util::source::SourceOffset;

pub const ACCESS_SLOT_FORM_NAME: &'static str = "access-slot";

/// Produces the syntactic form `(quote value)`.
pub fn quote(value: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("quote", [value], pos)
}

/// Produces the syntactic form `(function value)`.
pub fn function(value: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("function", [value], pos)
}

/// Produces the syntactic form `(quasiquote value)`.
pub fn quasiquote(value: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("quasiquote", [value], pos)
}

/// Produces the syntactic form `(unquote value)`.
pub fn unquote(value: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("unquote", [value], pos)
}

/// Produces the syntactic form `(unquote-spliced value)`.
pub fn unquote_spliced(value: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("unquote-spliced", [value], pos)
}

/// Produces the syntactic form `(array ...)`, given the tail of the
/// list of arguments.
pub fn array(tail: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::cons(SExpr::symbol("array", pos), tail, pos)
}

/// Produces the syntactic form `(dict ...)`, given the tail of the
/// list of arguments.
pub fn dict(tail: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::cons(SExpr::symbol("dict", pos), tail, pos)
}

/// Produces the syntactic form `(vector x y)`
pub fn vector2(x: SExpr, y: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("vector", [x, y], pos)
}

/// Produces the syntactic form `(vector x y z)`
pub fn vector3(x: SExpr, y: SExpr, z: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list("vector", [x, y, z], pos)
}

/// Produces the syntactic form `(access-slot x y)`
pub fn access_slot(x: SExpr, y: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::call_list(ACCESS_SLOT_FORM_NAME, [x, y], pos)
}

/// Produces a function call which will perform the equivalent of
/// `(x:get-node y)`.
pub fn get_node_on(x: SExpr, y: SExpr, pos: SourceOffset) -> SExpr {
  SExpr::list([
    SExpr::symbol("sys/get-node", pos),
    x,
    y,
  ], pos)
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_quote() {
    assert_eq!(
      quote(SExpr::int(9, SourceOffset(100)), SourceOffset(3)),
      SExpr::list(
        vec!(
          SExpr::symbol("quote", SourceOffset(3)),
          SExpr::int(9, SourceOffset(100)),
        ),
        SourceOffset(3),
      )
    )
  }

  #[test]
  fn test_function() {
    assert_eq!(
      function(SExpr::int(9, SourceOffset(100)), SourceOffset(3)),
      SExpr::list(
        vec!(
          SExpr::symbol("function", SourceOffset(3)),
          SExpr::int(9, SourceOffset(100)),
        ),
        SourceOffset(3),
      )
    )
  }

  #[test]
  fn test_quasiquote() {
    assert_eq!(
      quasiquote(SExpr::int(9, SourceOffset(100)), SourceOffset(3)),
      SExpr::list(
        vec!(
          SExpr::symbol("quasiquote", SourceOffset(3)),
          SExpr::int(9, SourceOffset(100)),
        ),
        SourceOffset(3),
      )
    )
  }

  #[test]
  fn test_unquote() {
    assert_eq!(
      unquote(SExpr::int(9, SourceOffset(100)), SourceOffset(3)),
      SExpr::list(
        vec!(
          SExpr::symbol("unquote", SourceOffset(3)),
          SExpr::int(9, SourceOffset(100)),
        ),
        SourceOffset(3),
      )
    )
  }

  #[test]
  fn test_unquote_spliced() {
    assert_eq!(
      unquote_spliced(SExpr::int(9, SourceOffset(100)), SourceOffset(3)),
      SExpr::list(
        vec!(
          SExpr::symbol("unquote-spliced", SourceOffset(3)),
          SExpr::int(9, SourceOffset(100)),
        ),
        SourceOffset(3),
      )
    )
  }

  // TODO The rest of these

}
